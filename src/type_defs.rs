// Partially generated by bindgen but we edit it despite their warnings
#![allow(dead_code)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]

use std::os::raw::c_void;

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe { *(core::ptr::addr_of!((*this).storage) as *const u8).add(byte_index) };
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val { byte | mask } else { byte & !mask }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe { (core::ptr::addr_of_mut!((*this).storage) as *mut u8).add(byte_index) };
        unsafe {
            *byte = Self::change_bit(*byte, index, val);
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if unsafe { Self::raw_get_bit(this, i + bit_offset) } {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            unsafe { Self::raw_set_bit(this, index + bit_offset, val_bit_is_set) };
        }
    }
}
#[derive(PartialEq, Copy, Clone, Hash, Debug, Default)]
#[repr(C)]
pub struct __BindgenComplex<T> {
    pub re: T,
    pub im: T,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Joystick {
    _unused: [u8; 0],
}
pub const SDLMod_KMOD_NONE: SDLMod = 0;
pub const SDLMod_KMOD_LSHIFT: SDLMod = 1;
pub const SDLMod_KMOD_RSHIFT: SDLMod = 2;
pub const SDLMod_KMOD_LCTRL: SDLMod = 64;
pub const SDLMod_KMOD_RCTRL: SDLMod = 128;
pub const SDLMod_KMOD_LALT: SDLMod = 256;
pub const SDLMod_KMOD_RALT: SDLMod = 512;
pub const SDLMod_KMOD_LMETA: SDLMod = 1024;
pub const SDLMod_KMOD_RMETA: SDLMod = 2048;
pub const SDLMod_KMOD_NUM: SDLMod = 4096;
pub const SDLMod_KMOD_CAPS: SDLMod = 8192;
pub const SDLMod_KMOD_MODE: SDLMod = 16384;
pub const SDLMod_KMOD_RESERVED: SDLMod = 32768;
pub type SDLMod = ::std::os::raw::c_uint;
pub const SDLKey_SDLK_UNKNOWN: SDLKey = 0;
pub const SDLKey_SDLK_FIRST: SDLKey = 0;
pub const SDLKey_SDLK_BACKSPACE: SDLKey = 8;
pub const SDLKey_SDLK_TAB: SDLKey = 9;
pub const SDLKey_SDLK_CLEAR: SDLKey = 12;
pub const SDLKey_SDLK_RETURN: SDLKey = 13;
pub const SDLKey_SDLK_PAUSE: SDLKey = 19;
pub const SDLKey_SDLK_ESCAPE: SDLKey = 27;
pub const SDLKey_SDLK_SPACE: SDLKey = 32;
pub const SDLKey_SDLK_EXCLAIM: SDLKey = 33;
pub const SDLKey_SDLK_QUOTEDBL: SDLKey = 34;
pub const SDLKey_SDLK_HASH: SDLKey = 35;
pub const SDLKey_SDLK_DOLLAR: SDLKey = 36;
pub const SDLKey_SDLK_AMPERSAND: SDLKey = 38;
pub const SDLKey_SDLK_QUOTE: SDLKey = 39;
pub const SDLKey_SDLK_LEFTPAREN: SDLKey = 40;
pub const SDLKey_SDLK_RIGHTPAREN: SDLKey = 41;
pub const SDLKey_SDLK_ASTERISK: SDLKey = 42;
pub const SDLKey_SDLK_PLUS: SDLKey = 43;
pub const SDLKey_SDLK_COMMA: SDLKey = 44;
pub const SDLKey_SDLK_MINUS: SDLKey = 45;
pub const SDLKey_SDLK_PERIOD: SDLKey = 46;
pub const SDLKey_SDLK_SLASH: SDLKey = 47;
pub const SDLKey_SDLK_0: SDLKey = 48;
pub const SDLKey_SDLK_1: SDLKey = 49;
pub const SDLKey_SDLK_2: SDLKey = 50;
pub const SDLKey_SDLK_3: SDLKey = 51;
pub const SDLKey_SDLK_4: SDLKey = 52;
pub const SDLKey_SDLK_5: SDLKey = 53;
pub const SDLKey_SDLK_6: SDLKey = 54;
pub const SDLKey_SDLK_7: SDLKey = 55;
pub const SDLKey_SDLK_8: SDLKey = 56;
pub const SDLKey_SDLK_9: SDLKey = 57;
pub const SDLKey_SDLK_COLON: SDLKey = 58;
pub const SDLKey_SDLK_SEMICOLON: SDLKey = 59;
pub const SDLKey_SDLK_LESS: SDLKey = 60;
pub const SDLKey_SDLK_EQUALS: SDLKey = 61;
pub const SDLKey_SDLK_GREATER: SDLKey = 62;
pub const SDLKey_SDLK_QUESTION: SDLKey = 63;
pub const SDLKey_SDLK_AT: SDLKey = 64;
pub const SDLKey_SDLK_LEFTBRACKET: SDLKey = 91;
pub const SDLKey_SDLK_BACKSLASH: SDLKey = 92;
pub const SDLKey_SDLK_RIGHTBRACKET: SDLKey = 93;
pub const SDLKey_SDLK_CARET: SDLKey = 94;
pub const SDLKey_SDLK_UNDERSCORE: SDLKey = 95;
pub const SDLKey_SDLK_BACKQUOTE: SDLKey = 96;
pub const SDLKey_SDLK_a: SDLKey = 97;
pub const SDLKey_SDLK_b: SDLKey = 98;
pub const SDLKey_SDLK_c: SDLKey = 99;
pub const SDLKey_SDLK_d: SDLKey = 100;
pub const SDLKey_SDLK_e: SDLKey = 101;
pub const SDLKey_SDLK_f: SDLKey = 102;
pub const SDLKey_SDLK_g: SDLKey = 103;
pub const SDLKey_SDLK_h: SDLKey = 104;
pub const SDLKey_SDLK_i: SDLKey = 105;
pub const SDLKey_SDLK_j: SDLKey = 106;
pub const SDLKey_SDLK_k: SDLKey = 107;
pub const SDLKey_SDLK_l: SDLKey = 108;
pub const SDLKey_SDLK_m: SDLKey = 109;
pub const SDLKey_SDLK_n: SDLKey = 110;
pub const SDLKey_SDLK_o: SDLKey = 111;
pub const SDLKey_SDLK_p: SDLKey = 112;
pub const SDLKey_SDLK_q: SDLKey = 113;
pub const SDLKey_SDLK_r: SDLKey = 114;
pub const SDLKey_SDLK_s: SDLKey = 115;
pub const SDLKey_SDLK_t: SDLKey = 116;
pub const SDLKey_SDLK_u: SDLKey = 117;
pub const SDLKey_SDLK_v: SDLKey = 118;
pub const SDLKey_SDLK_w: SDLKey = 119;
pub const SDLKey_SDLK_x: SDLKey = 120;
pub const SDLKey_SDLK_y: SDLKey = 121;
pub const SDLKey_SDLK_z: SDLKey = 122;
pub const SDLKey_SDLK_DELETE: SDLKey = 127;
pub const SDLKey_SDLK_WORLD_0: SDLKey = 160;
pub const SDLKey_SDLK_WORLD_1: SDLKey = 161;
pub const SDLKey_SDLK_WORLD_2: SDLKey = 162;
pub const SDLKey_SDLK_WORLD_3: SDLKey = 163;
pub const SDLKey_SDLK_WORLD_4: SDLKey = 164;
pub const SDLKey_SDLK_WORLD_5: SDLKey = 165;
pub const SDLKey_SDLK_WORLD_6: SDLKey = 166;
pub const SDLKey_SDLK_WORLD_7: SDLKey = 167;
pub const SDLKey_SDLK_WORLD_8: SDLKey = 168;
pub const SDLKey_SDLK_WORLD_9: SDLKey = 169;
pub const SDLKey_SDLK_WORLD_10: SDLKey = 170;
pub const SDLKey_SDLK_WORLD_11: SDLKey = 171;
pub const SDLKey_SDLK_WORLD_12: SDLKey = 172;
pub const SDLKey_SDLK_WORLD_13: SDLKey = 173;
pub const SDLKey_SDLK_WORLD_14: SDLKey = 174;
pub const SDLKey_SDLK_WORLD_15: SDLKey = 175;
pub const SDLKey_SDLK_WORLD_16: SDLKey = 176;
pub const SDLKey_SDLK_WORLD_17: SDLKey = 177;
pub const SDLKey_SDLK_WORLD_18: SDLKey = 178;
pub const SDLKey_SDLK_WORLD_19: SDLKey = 179;
pub const SDLKey_SDLK_WORLD_20: SDLKey = 180;
pub const SDLKey_SDLK_WORLD_21: SDLKey = 181;
pub const SDLKey_SDLK_WORLD_22: SDLKey = 182;
pub const SDLKey_SDLK_WORLD_23: SDLKey = 183;
pub const SDLKey_SDLK_WORLD_24: SDLKey = 184;
pub const SDLKey_SDLK_WORLD_25: SDLKey = 185;
pub const SDLKey_SDLK_WORLD_26: SDLKey = 186;
pub const SDLKey_SDLK_WORLD_27: SDLKey = 187;
pub const SDLKey_SDLK_WORLD_28: SDLKey = 188;
pub const SDLKey_SDLK_WORLD_29: SDLKey = 189;
pub const SDLKey_SDLK_WORLD_30: SDLKey = 190;
pub const SDLKey_SDLK_WORLD_31: SDLKey = 191;
pub const SDLKey_SDLK_WORLD_32: SDLKey = 192;
pub const SDLKey_SDLK_WORLD_33: SDLKey = 193;
pub const SDLKey_SDLK_WORLD_34: SDLKey = 194;
pub const SDLKey_SDLK_WORLD_35: SDLKey = 195;
pub const SDLKey_SDLK_WORLD_36: SDLKey = 196;
pub const SDLKey_SDLK_WORLD_37: SDLKey = 197;
pub const SDLKey_SDLK_WORLD_38: SDLKey = 198;
pub const SDLKey_SDLK_WORLD_39: SDLKey = 199;
pub const SDLKey_SDLK_WORLD_40: SDLKey = 200;
pub const SDLKey_SDLK_WORLD_41: SDLKey = 201;
pub const SDLKey_SDLK_WORLD_42: SDLKey = 202;
pub const SDLKey_SDLK_WORLD_43: SDLKey = 203;
pub const SDLKey_SDLK_WORLD_44: SDLKey = 204;
pub const SDLKey_SDLK_WORLD_45: SDLKey = 205;
pub const SDLKey_SDLK_WORLD_46: SDLKey = 206;
pub const SDLKey_SDLK_WORLD_47: SDLKey = 207;
pub const SDLKey_SDLK_WORLD_48: SDLKey = 208;
pub const SDLKey_SDLK_WORLD_49: SDLKey = 209;
pub const SDLKey_SDLK_WORLD_50: SDLKey = 210;
pub const SDLKey_SDLK_WORLD_51: SDLKey = 211;
pub const SDLKey_SDLK_WORLD_52: SDLKey = 212;
pub const SDLKey_SDLK_WORLD_53: SDLKey = 213;
pub const SDLKey_SDLK_WORLD_54: SDLKey = 214;
pub const SDLKey_SDLK_WORLD_55: SDLKey = 215;
pub const SDLKey_SDLK_WORLD_56: SDLKey = 216;
pub const SDLKey_SDLK_WORLD_57: SDLKey = 217;
pub const SDLKey_SDLK_WORLD_58: SDLKey = 218;
pub const SDLKey_SDLK_WORLD_59: SDLKey = 219;
pub const SDLKey_SDLK_WORLD_60: SDLKey = 220;
pub const SDLKey_SDLK_WORLD_61: SDLKey = 221;
pub const SDLKey_SDLK_WORLD_62: SDLKey = 222;
pub const SDLKey_SDLK_WORLD_63: SDLKey = 223;
pub const SDLKey_SDLK_WORLD_64: SDLKey = 224;
pub const SDLKey_SDLK_WORLD_65: SDLKey = 225;
pub const SDLKey_SDLK_WORLD_66: SDLKey = 226;
pub const SDLKey_SDLK_WORLD_67: SDLKey = 227;
pub const SDLKey_SDLK_WORLD_68: SDLKey = 228;
pub const SDLKey_SDLK_WORLD_69: SDLKey = 229;
pub const SDLKey_SDLK_WORLD_70: SDLKey = 230;
pub const SDLKey_SDLK_WORLD_71: SDLKey = 231;
pub const SDLKey_SDLK_WORLD_72: SDLKey = 232;
pub const SDLKey_SDLK_WORLD_73: SDLKey = 233;
pub const SDLKey_SDLK_WORLD_74: SDLKey = 234;
pub const SDLKey_SDLK_WORLD_75: SDLKey = 235;
pub const SDLKey_SDLK_WORLD_76: SDLKey = 236;
pub const SDLKey_SDLK_WORLD_77: SDLKey = 237;
pub const SDLKey_SDLK_WORLD_78: SDLKey = 238;
pub const SDLKey_SDLK_WORLD_79: SDLKey = 239;
pub const SDLKey_SDLK_WORLD_80: SDLKey = 240;
pub const SDLKey_SDLK_WORLD_81: SDLKey = 241;
pub const SDLKey_SDLK_WORLD_82: SDLKey = 242;
pub const SDLKey_SDLK_WORLD_83: SDLKey = 243;
pub const SDLKey_SDLK_WORLD_84: SDLKey = 244;
pub const SDLKey_SDLK_WORLD_85: SDLKey = 245;
pub const SDLKey_SDLK_WORLD_86: SDLKey = 246;
pub const SDLKey_SDLK_WORLD_87: SDLKey = 247;
pub const SDLKey_SDLK_WORLD_88: SDLKey = 248;
pub const SDLKey_SDLK_WORLD_89: SDLKey = 249;
pub const SDLKey_SDLK_WORLD_90: SDLKey = 250;
pub const SDLKey_SDLK_WORLD_91: SDLKey = 251;
pub const SDLKey_SDLK_WORLD_92: SDLKey = 252;
pub const SDLKey_SDLK_WORLD_93: SDLKey = 253;
pub const SDLKey_SDLK_WORLD_94: SDLKey = 254;
pub const SDLKey_SDLK_WORLD_95: SDLKey = 255;
pub const SDLKey_SDLK_KP0: SDLKey = 256;
pub const SDLKey_SDLK_KP1: SDLKey = 257;
pub const SDLKey_SDLK_KP2: SDLKey = 258;
pub const SDLKey_SDLK_KP3: SDLKey = 259;
pub const SDLKey_SDLK_KP4: SDLKey = 260;
pub const SDLKey_SDLK_KP5: SDLKey = 261;
pub const SDLKey_SDLK_KP6: SDLKey = 262;
pub const SDLKey_SDLK_KP7: SDLKey = 263;
pub const SDLKey_SDLK_KP8: SDLKey = 264;
pub const SDLKey_SDLK_KP9: SDLKey = 265;
pub const SDLKey_SDLK_KP_PERIOD: SDLKey = 266;
pub const SDLKey_SDLK_KP_DIVIDE: SDLKey = 267;
pub const SDLKey_SDLK_KP_MULTIPLY: SDLKey = 268;
pub const SDLKey_SDLK_KP_MINUS: SDLKey = 269;
pub const SDLKey_SDLK_KP_PLUS: SDLKey = 270;
pub const SDLKey_SDLK_KP_ENTER: SDLKey = 271;
pub const SDLKey_SDLK_KP_EQUALS: SDLKey = 272;
pub const SDLKey_SDLK_UP: SDLKey = 273;
pub const SDLKey_SDLK_DOWN: SDLKey = 274;
pub const SDLKey_SDLK_RIGHT: SDLKey = 275;
pub const SDLKey_SDLK_LEFT: SDLKey = 276;
pub const SDLKey_SDLK_INSERT: SDLKey = 277;
pub const SDLKey_SDLK_HOME: SDLKey = 278;
pub const SDLKey_SDLK_END: SDLKey = 279;
pub const SDLKey_SDLK_PAGEUP: SDLKey = 280;
pub const SDLKey_SDLK_PAGEDOWN: SDLKey = 281;
pub const SDLKey_SDLK_F1: SDLKey = 282;
pub const SDLKey_SDLK_F2: SDLKey = 283;
pub const SDLKey_SDLK_F3: SDLKey = 284;
pub const SDLKey_SDLK_F4: SDLKey = 285;
pub const SDLKey_SDLK_F5: SDLKey = 286;
pub const SDLKey_SDLK_F6: SDLKey = 287;
pub const SDLKey_SDLK_F7: SDLKey = 288;
pub const SDLKey_SDLK_F8: SDLKey = 289;
pub const SDLKey_SDLK_F9: SDLKey = 290;
pub const SDLKey_SDLK_F10: SDLKey = 291;
pub const SDLKey_SDLK_F11: SDLKey = 292;
pub const SDLKey_SDLK_F12: SDLKey = 293;
pub const SDLKey_SDLK_F13: SDLKey = 294;
pub const SDLKey_SDLK_F14: SDLKey = 295;
pub const SDLKey_SDLK_F15: SDLKey = 296;
pub const SDLKey_SDLK_NUMLOCK: SDLKey = 300;
pub const SDLKey_SDLK_CAPSLOCK: SDLKey = 301;
pub const SDLKey_SDLK_SCROLLOCK: SDLKey = 302;
pub const SDLKey_SDLK_RSHIFT: SDLKey = 303;
pub const SDLKey_SDLK_LSHIFT: SDLKey = 304;
pub const SDLKey_SDLK_RCTRL: SDLKey = 305;
pub const SDLKey_SDLK_LCTRL: SDLKey = 306;
pub const SDLKey_SDLK_RALT: SDLKey = 307;
pub const SDLKey_SDLK_LALT: SDLKey = 308;
pub const SDLKey_SDLK_RMETA: SDLKey = 309;
pub const SDLKey_SDLK_LMETA: SDLKey = 310;
#[doc = "< Left \"Windows\" key"]
pub const SDLKey_SDLK_LSUPER: SDLKey = 311;
#[doc = "< Right \"Windows\" key"]
pub const SDLKey_SDLK_RSUPER: SDLKey = 312;
#[doc = "< \"Alt Gr\" key"]
pub const SDLKey_SDLK_MODE: SDLKey = 313;
#[doc = "< Multi-key compose key"]
pub const SDLKey_SDLK_COMPOSE: SDLKey = 314;
pub const SDLKey_SDLK_HELP: SDLKey = 315;
pub const SDLKey_SDLK_PRINT: SDLKey = 316;
pub const SDLKey_SDLK_SYSREQ: SDLKey = 317;
pub const SDLKey_SDLK_BREAK: SDLKey = 318;
pub const SDLKey_SDLK_MENU: SDLKey = 319;
#[doc = "< Power Macintosh power key"]
pub const SDLKey_SDLK_POWER: SDLKey = 320;
#[doc = "< Some european keyboards"]
pub const SDLKey_SDLK_EURO: SDLKey = 321;
#[doc = "< Atari keyboard has Undo"]
pub const SDLKey_SDLK_UNDO: SDLKey = 322;
pub const SDLKey_SDLK_LAST: SDLKey = 323;
pub type SDLKey = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_PixelFormat {
    pub palette: *mut ::std::os::raw::c_void,
    pub BitsPerPixel: u8,
    pub BytesPerPixel: u8,
    pub Rloss: u8,
    pub Gloss: u8,
    pub Bloss: u8,
    pub Aloss: u8,
    pub Rshift: u8,
    pub Gshift: u8,
    pub Bshift: u8,
    pub Ashift: u8,
    pub Rmask: u32,
    pub Gmask: u32,
    pub Bmask: u32,
    pub Amask: u32,
    pub colorkey: u32,
    pub alpha: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_VideoInfo {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub blit_fill: u32,
    pub video_mem: u32,
    pub vfmt: *mut SDL_PixelFormat,
}
impl SDL_VideoInfo {
    #[inline]
    pub fn hw_available(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hw_available(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hw_available_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hw_available_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn wm_available(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wm_available(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wm_available_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_wm_available_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn blit_hw(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_blit_hw(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn blit_hw_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_blit_hw_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn blit_hw_CC(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_blit_hw_CC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn blit_hw_CC_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_blit_hw_CC_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn blit_hw_A(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_blit_hw_A(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn blit_hw_A_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_blit_hw_A_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn blit_sw(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_blit_sw(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn blit_sw_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_blit_sw_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn blit_sw_CC(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_blit_sw_CC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn blit_sw_CC_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_blit_sw_CC_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn blit_sw_A(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_blit_sw_A(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn blit_sw_A_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_blit_sw_A_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hw_available: u32,
        wm_available: u32,
        blit_hw: u32,
        blit_hw_CC: u32,
        blit_hw_A: u32,
        blit_sw: u32,
        blit_sw_CC: u32,
        blit_sw_A: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hw_available: u32 = unsafe { ::std::mem::transmute(hw_available) };
            hw_available as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let wm_available: u32 = unsafe { ::std::mem::transmute(wm_available) };
            wm_available as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let blit_hw: u32 = unsafe { ::std::mem::transmute(blit_hw) };
            blit_hw as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let blit_hw_CC: u32 = unsafe { ::std::mem::transmute(blit_hw_CC) };
            blit_hw_CC as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let blit_hw_A: u32 = unsafe { ::std::mem::transmute(blit_hw_A) };
            blit_hw_A as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let blit_sw: u32 = unsafe { ::std::mem::transmute(blit_sw) };
            blit_sw as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let blit_sw_CC: u32 = unsafe { ::std::mem::transmute(blit_sw_CC) };
            blit_sw_CC as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let blit_sw_A: u32 = unsafe { ::std::mem::transmute(blit_sw_A) };
            blit_sw_A as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Rect {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub w: ::std::os::raw::c_int,
    pub h: ::std::os::raw::c_int,
}

#[repr(C)]
pub enum SDL_GLattr {
    RED_SIZE = 0,
    GREEN_SIZE = 1,
    BLUE_SIZE = 2,
    ALPHA_SIZE = 3,
    DOUBLEBUFFER = 4,
    BUFFER_SIZE = 5,
    DEPTH_SIZE = 6,
    STENCIL_SIZE = 7,
    ACCUM_RED_SIZE = 8,
    ACCUM_GREEN_SIZE = 9,
    ACCUM_BLUE_SIZE = 10,
    ACCUM_ALPHA_SIZE = 11,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_keysym {
    pub scancode: u8,
    pub sym: SDLKey,
    pub mod_: SDLMod,
    pub unicode: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_SysWMmsg {
    pub version: ::std::os::raw::c_int,
    pub data: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_Event {
    pub type_: u8,
    pub active: SDL_Event__bindgen_ty_1,
    pub key: SDL_Event__bindgen_ty_2,
    pub motion: SDL_Event__bindgen_ty_3,
    pub button: SDL_Event__bindgen_ty_4,
    pub jaxis: SDL_Event__bindgen_ty_5,
    pub jball: SDL_Event__bindgen_ty_6,
    pub jhat: SDL_Event__bindgen_ty_7,
    pub jbutton: SDL_Event__bindgen_ty_8,
    pub resize: SDL_Event__bindgen_ty_9,
    pub expose: SDL_Event__bindgen_ty_10,
    pub quit: SDL_Event__bindgen_ty_11,
    pub user: SDL_Event__bindgen_ty_12,
    pub syswm: SDL_Event__bindgen_ty_13,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Event__bindgen_ty_1 {
    pub type_: u8,
    pub gain: u8,
    pub state: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Event__bindgen_ty_2 {
    pub type_: u8,
    pub state: u8,
    pub keysym: SDL_keysym,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Event__bindgen_ty_3 {
    pub type_: u8,
    pub padding: u8,
    pub state: u8,
    pub x: u16,
    pub y: u16,
    pub xrel: i16,
    pub yrel: i16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Event__bindgen_ty_4 {
    pub type_: u8,
    pub padding: u8,
    pub button: u8,
    pub state: u8,
    pub x: u16,
    pub y: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Event__bindgen_ty_5 {
    pub type_: u8,
    pub which: u8,
    pub axis: u8,
    pub value: i16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Event__bindgen_ty_6 {
    pub type_: u8,
    pub which: u8,
    pub ball: u8,
    pub xrel: i16,
    pub yrel: i16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Event__bindgen_ty_7 {
    pub type_: u8,
    pub which: u8,
    pub hat: u8,
    pub value: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Event__bindgen_ty_8 {
    pub type_: u8,
    pub which: u8,
    pub button: u8,
    pub state: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Event__bindgen_ty_9 {
    pub type_: u8,
    pub w: ::std::os::raw::c_int,
    pub h: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Event__bindgen_ty_10 {
    pub type_: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Event__bindgen_ty_11 {
    pub type_: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Event__bindgen_ty_12 {
    pub type_: u8,
    pub code: ::std::os::raw::c_int,
    pub data1: *mut ::std::os::raw::c_void,
    pub data2: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Event__bindgen_ty_13 {
    pub type_: u8,
    pub msg: *mut SDL_SysWMmsg,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_RWops {
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut SDL_RWops,
            offset: ::std::os::raw::c_int,
            whence: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut SDL_RWops,
            ptr: *mut ::std::os::raw::c_void,
            size: ::std::os::raw::c_int,
            maxnum: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut SDL_RWops,
            ptr: *const ::std::os::raw::c_void,
            size: ::std::os::raw::c_int,
            num: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub close: ::std::option::Option<
        unsafe extern "C" fn(context: *mut SDL_RWops) -> ::std::os::raw::c_int,
    >,
    pub type_: u32,
    pub hidden: SDL_RWops__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_RWops__bindgen_ty_1 {
    pub stdio: SDL_RWops__bindgen_ty_1__bindgen_ty_1,
    pub mem: SDL_RWops__bindgen_ty_1__bindgen_ty_2,
    pub unknown: SDL_RWops__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_RWops__bindgen_ty_1__bindgen_ty_1 {
    pub autoclose: ::std::os::raw::c_int,
    pub fp: *mut c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_RWops__bindgen_ty_1__bindgen_ty_2 {
    pub base: *mut u8,
    pub here: *mut u8,
    pub stop: *mut u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_RWops__bindgen_ty_1__bindgen_ty_3 {
    pub data1: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Surface {
    pub flags: u32,
    pub format: *mut SDL_PixelFormat,
    pub w: ::std::os::raw::c_int,
    pub h: ::std::os::raw::c_int,
    pub pitch: u16,
    pub pixels: *mut ::std::os::raw::c_void,
    pub clip_rect: SDL_Rect,
    pub refcount: ::std::os::raw::c_int,
}
#[repr(C)]
pub enum SDL_EventType {
    SDL_NOEVENT = 0,
    /**< Unused (do not remove) */
    SDL_ACTIVEEVENT,
    /**< Application loses/gains visibility */
    SDL_KEYDOWN,
    /**< Keys pressed */
    SDL_KEYUP,
    /**< Keys released */
    SDL_MOUSEMOTION,
    /**< Mouse moved */
    SDL_MOUSEBUTTONDOWN,
    /**< Mouse button pressed */
    SDL_MOUSEBUTTONUP,
    /**< Mouse button released */
    SDL_JOYAXISMOTION,
    /**< Joystick axis motion */
    SDL_JOYBALLMOTION,
    /**< Joystick trackball motion */
    SDL_JOYHATMOTION,
    /**< Joystick hat position change */
    SDL_JOYBUTTONDOWN,
    /**< Joystick button pressed */
    SDL_JOYBUTTONUP,
    /**< Joystick button released */
    SDL_QUIT,
    /**< User-requested quit */
    SDL_SYSWMEVENT,
    /**< System specific event */
    SDL_EVENT_RESERVEDA,
    /**< Reserved for future use.. */
    SDL_EVENT_RESERVEDB,
    /**< Reserved for future use.. */
    SDL_VIDEORESIZE,
    /**< User resized video mode */
    SDL_VIDEOEXPOSE,
    /**< Screen needs to be redrawn */
    SDL_EVENT_RESERVED2,
    /**< Reserved for future use.. */
    SDL_EVENT_RESERVED3,
    /**< Reserved for future use.. */
    SDL_EVENT_RESERVED4,
    /**< Reserved for future use.. */
    SDL_EVENT_RESERVED5,
    /**< Reserved for future use.. */
    SDL_EVENT_RESERVED6,
    /**< Reserved for future use.. */
    SDL_EVENT_RESERVED7,
    /**< Reserved for future use.. */
    /** Events SDL_USEREVENT through SDL_MAXEVENTS-1 are for your use */
    SDL_USEREVENT = 24,
    /** This last event is only for bounding internal arrays
    	*  It is the number of bits in the event mask datatype -- Uint32
     */
    SDL_NUMEVENTS = 32,
}
